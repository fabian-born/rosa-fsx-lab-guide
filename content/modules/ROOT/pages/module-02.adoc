
= Deploy stateful applicaiton

[#deploy]
== Deploy MySQL stateful application [[deploy-mysql]]

* Stateful applications, like databases, need to maintain data across pod restarts.
* Using pvc's, Trident ensures data persistence for these applications.
* Deploying MySQL as a sample stateful application gives a practical example of how Trident integrates with OpenShift to manage data for stateful applications, ensuring data is not lost when pods are moved or restarted.

=== Setup the MySQL Project

Before we create the MySQL application, we will creat a `mysql` project and store the application’s username and password in a Secret.

Create the mysql namespace
[source,bash]
----
oc create ns mysql
----

We'll use the `mysql` project as our default project
[source,bash]
----
oc project mysql
----

Create the mysql secret

`password` is the password but can be chagned in the `mysql-secret.yml` file

[source,bash]
----
oc apply -f mysql-secret.yml
----

Verify the secret was created.

[source,bash]
----
oc get secrets | awk '/NAME|mysql-password/'
----
[listing]
----
NAME                       TYPE                                  DATA   AGE
mysql-password             opaque                                1      1h34m
----

=== Create a pvc for the MySQL application

[source,bash]
----
oc apply -f mysql-pvc.yml
----


Verify the pvc's are created by the MySQL application.

[source,shell]
----
oc get pvc
----
[listing]
----
NAME          STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
mysql-volume  Bound    pvc-676d059c-1480-4e36-963e-2249efc70331   10Gi       RWX            trident-csi    4h4m
----

=== MySQL Application Deployment

Next we will deploy the MySQL application on the ROSA cluster.

Open `mysql-deployment.yml` and review the details –metadata, replicas, and storageclass name.

For simplicity in this lab, we are only going to create one (1) replica set.


Execute the following command.

NOTE: Ignore any warnings about PodSecurity

[source,shell]
----
oc apply -f mysql-deployment.yml
----

Verify the application deployment.  It will take a minute for the container to start.

[source,shell]
----
oc get pods
----

[listing]
----
NAME                        READY   STATUS    RESTARTS   AGE
mysql-fsx-7db4f45b8-mmfzv   1/1     Running   0          40s

----

=== Create a service for the MySQL application

* A OPenShift service acts as an internal load balancer. It provides a stable endpoint through which other pods within the cluster can access the MySQL application, regardless of the individual states of the MySQL pods.
* By specifying a service for MySQL, you provide a consistent internal address for the database, ensuring seamless communication even as pods are scaled or restarted.

[source,shell]
----
oc apply -f mysql-service.yml
----

Verify the service.

[source,shell]
----
oc get svc
----
[listing]
----
NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
mysql   ClusterIP   None         <none>        3306/TCP   4h3m
----

=== Create MySQL client

* The MySQL client is used to access the MySQL application using the service we created.
* This provides a consistent entry point into the database.

Review the content of `mysql-client.yml` and then deploy the MySQL client using the following command.

[source,shell]
----
oc apply -f mysql-client.yml
----

Verify the pod status.

[source,shell]
----
oc get pods
----
[listing]
----
NAME                         READY   STATUS    RESTARTS   AGE
mysql-client                 1/1     Running   0          7s
----

=== Create a sample database

Log in to the MySQL client pod.

[source,shell]
----
oc exec --stdin --tty mysql-client -- sh
----

Install the MySQL client tool.

[source,shell]
----
apk add mysql-client
----

Within the `mysql-client` pod, connect to the MySQL server.

[source,shell]
----
mysql -u root -p -h mysql.mysql.svc.cluster.local
----

Enter the password that is stored in `mysql-secrets.yml`.

Once connected, we will create a new database.

From the `MySQL [(none)]>` prompt enter the following:

[source]
----
CREATE DATABASE erp;
CREATE TABLE erp.Persons ( ID int, FirstName varchar(255),Lastname varchar(255));
INSERT INTO erp.Persons (ID, FirstName, LastName) values (1234 , "John" , "Doe");
commit;
select * from erp.Persons;
----

[listing]
----
+------+-----------+----------+
| ID | FirstName | Lastname |
+------+-----------+----------+
| 1234 | John | Doe |
+------+-----------+----------+
----

Type `exit` to exit the mysql server and `exit` again to exit the pod.  You should now be back at the bastion prompt



[#create-snapshop]
== Creating Snapshots [[creating-snapshots]]

* Snapshots are point-in-time copies of your data, crucial for backup and disaster recovery.
* Here, you’ll learn how to use Trident with FSx for ONTAP to create snapshots for backup, and how to restore your application data from these snapshots.
* This is vital for protecting your application against data loss.


=== Create the volume snapshot class and snapshot

[source,bash]
----
oc apply -f volume-snapshot-class.yml
----

Create a snapshot of the exising MySQl data

[source,bash]
----
oc apply -f volume-snapshot.yml
----

Use the following to find the name of the snapshot.

[source, bash]
----
oc get volumesnapshots
----

[#recovery]
== Data Recovery

* This illustrates the use of snapshots in real-world scenarios through the deletion and restoration of the database.
* This demonstrates the quick and efficient data recovery capabilities of Trident and FSx for ONTAP in managing and protecting OpenShift stateful application data.

=== Delete the `erp` database.

To delete the database `erp` after creating a snapshot follow these steps.

Log back in to the `mysql-cleint`

[source,bash]
----
oc exec --stdin --tty mysql-client -- sh
----

Login to the MYSQL database.

[source,bash]
----
mysql -u root -p -h mysql.mysql.svc.cluster.local
----

Delete the `erp`` database at the `MySQL [(none)]>` prompt

[source,sql]
----
DROP DATABASE erp;
----

After executing the DROP command, the database "erp" will be deleted, and you should see a message like:

[listing]
----
Query OK, 1 row affected
----

Verify the database has been deleted.
[source,sql]
----
SHOW DATABASES;
----

Exit back out to the bastion prompt.

=== Restore the snapshot

* Restoring a snapshot to a new pvc creates a new volume that mirrors the data state captured in the snapshot.
* This process enables data recovery or access as it existed at the snapshot's creation, without altering the original volume.

Create a new pvc from the snapshot.

NOTE: The name of the new pvc is `mysql-volume-clone`

[source,bash]
----
oc apply -f mysql-pvc-clone.yml
----

=== Update the MySQL application

We need to to update the `mysql` application to point to the new pvc.

Edit `mysql-deployment.yml` with your favorite editor, `vim`

Update the last line with the name of the pvc we just created, `mysql-volume-clone`

[source]
----
claimName: mysql-volume-clone
----

Redeploy the application.  This will recreate the pod so it points to the cloned pvc.
[source,bash]
----
oc apply -f mysql-deployment.yml
----

Verify the new pod is running.  This may take a minute.

[source,bash]
----
oc get pods
----

[#validate]
== Validate Database Restoration [[validation]]

* Validation confirms that the restored data is complete and accurate, maintaining the integrity of the database after a recovery process.
* Validation helps in identifying any issues or gaps in the restoration process, allowing for timely corrections


We can now check that our data has been restored.


[source,bash]
----
oc exec --stdin --tty mysql-client -- sh
----
[source,bash]
----
mysql -u root -p -h mysql.mysql.svc.cluster.local
----

Show Databases

[source,sql]
----
MySQL [(none)]> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| erp                |
+--------------------+
----

Show database data

[source,sql]
----
MySQL [(none)]> select * from erp.Persons;
+------+-----------+----------+
| ID   | FirstName | Lastname |
+------+-----------+----------+
| 1234 | John      | Doe      |
+------+-----------+----------+
----


Congrats.  You have completed the lab!
